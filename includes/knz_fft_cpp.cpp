//----------------------------------------------------------------------
//  Fast Furie Transformer - быстрое преобразование Фурье для Си++ (g++)
//  Князев Алексей, октябрь 2005
//----------------------------------------------------------------------
#include <math.h>
#include <string.h>

#include "knz_fft_cpp.h"

//функция инверсии битов относительно медианы. p - порядок, т.е. общее количество бит
////например, если p=4 (числа i отображены в двоичном представлении)
////p(0001,4) = 1000
////p(0011,4) = 1100
////p(0111,4) = 1110
////p(1010,4) = 0101
////данный алгоритм требуется для подготовки исходного массива быстрого Фурье преобразования
////порядка p (например, для 1024-точечной схемы p=10)
int reverse(int i, int p)
{
  int shift = p-1;
  unsigned int low_mask = 1;
  unsigned int high_mask = 1 << shift;
  unsigned int res;

  for (res=0; shift>=0; low_mask <<= 1, high_mask >>= 1, shift -= 2)
    res |= ((i & low_mask) << shift) | ((i & high_mask) >> shift);
  return res;
}

//быстрое преобразование Фурье
//p - порядок задачи, т.е для 1024-точечного пребразования Фурье p=10 (2^p = N)
//in - входной массив отсчетов сигнала размерности 2^p
//out - указатель на выходной массив спектральных отсчетов размерности 2^p
//-----------------------------
//Возможная оптимизация: алгоритм написан с учетом правильного масштабирования
//спектральных составляющих. Если это не нужно, то можно убрать умножение
//отсчетов сигнала на 2 при подготовке исходных данных, и умножение на 0.5
//в самом внутреннем цикле преобразования.
void fft(int p, double *in, KNZComplex **out)
{
  int n_max = 1 << p;
  KNZComplex w,foo;
  float pi2 = 2 * 3.1415926535897932384626433832795;
  float dummy;
  //Nd2 - это N делить на 2
  //kpNd2 - это k плюс Nd2
  int n,Nd2,k,kpNd2,m;

  //обнулим массив спектральных отсчетов
  memset((*out),0,n_max*sizeof(KNZComplex));

  //готовим массив исходных данных (p-мерная сортировка по четности)
  for (n=0;n<n_max;n++) {
    k = reverse(n,p);
    (*out)[k].re = in[n]*2;
  }

  //собственно само преобразование
  for (n=2, Nd2=1; n<=n_max; Nd2=n, n+=n)
  {
    for (k=0;k<Nd2;k++) {
      //w := cexp(-I*pi2*k/n);
	dummy = pi2*k/n;
	w.re  = cos(dummy);
	w.im  = -sin(dummy);

      for(m=k; m < n_max; m +=n) {
	kpNd2 = m + Nd2;
	foo.re = w.re*(*out)[kpNd2].re-w.im*(*out)[kpNd2].im;
	foo.im = w.re*(*out)[kpNd2].im+w.im*(*out)[kpNd2].re;

	(*out)[kpNd2].re = ((*out)[m].re - foo.re)*0.5;
	(*out)[kpNd2].im = ((*out)[m].im - foo.im)*0.5;

	(*out)[m].re = ((*out)[m].re + foo.re)*0.5;
	(*out)[m].im = ((*out)[m].im + foo.im)*0.5;
      }
    }
  }
}
